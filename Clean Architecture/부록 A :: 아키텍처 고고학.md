### 📕 조합 회계 시스템
- 애플리케이션이 시작되면 특정 터미널 버퍼가 가득 찰 때까지 출력을 생성
- 버퍼가 가득 차면 감시 프로그램은 해당 애플리케이션을 스왑 아웃하고 새로운 어플리케이션을 스왑 인
- 감시 프로그램은 터미널 버퍼가 거의 빌 때까지 버퍼의 내용을 초당 30문자의 속도로 흘려보냄
- 그 후 애플리케이션을 다시 스왑 인 하여 버퍼를 채움

<br>

#### 경계
1. 문자 출력 경계
의존성이 제어 흐름과 동일한 방향을 가리킴
애플리케이션은 감시 프로그램에 대해 컴파일 타임의 의존성을 가짐
제어흐름도 애플리케이션에서 감시 프로그램으로 전달
-> 출력을 어떤 장치로 보내는지 애플리케이션은 알지 못하게 함

2. 
감시 프로그램은 애플리케이션을 구동했지만 애플리케이션에 대한 컴파일 타임의 의존성이 없음
제어 흐름은 감시 프로그램에서 애플리케이션으로 전달
-> 의존성 역전

어떻게 의존성을 역전시킬 수 있었나?
오버레이 영역에서 모든 애플리케이션을 같은 메모리 주소로 이동시킴으로써 애플리케이션을 구동시켰다.
이 경계에서는 애플리케이션의 메모리 시작점 외에는 애플리케이션에 대해서 어떤 것도 감시 프로그램이 알지 못하도록 함

<br>

##### * 오버레이 : 데이터나 인스트럭션 블록을 다른 블록으로 교체하는 것을 의미한다. 오버레이는 컴퓨터의 메인 메모리보다 큰 프로그램을 실행할 수 있게끔하는 프로그래밍 방법이다. 주로 가상 메모리를 지원하지 않는 임베디드 시스템에서 많이 사용된다.

##### 페이지를 디스크에서 읽어 들이는 과정을 스왑 인(Swap In), 적재된 페이지를 디스크로 저장하는 과정을 스왑 아웃(Swap out)이라 하고, 이들 두 과정을 스와핑(Swapping)이라 한다. 스왑 아웃은 메모리가 부족할 때 이루어지고, 이때 스왑 아웃시킬 페이지를 선택하는 일을 페이지 교체라고 한다.

##### * 스와핑 : 메모리에 올라온 프로세스의 주소 공간 전체를 디스크의 스왑 영역(swap area)에 일시적으로 내려놓는 것을 말한다. / 프로세스가 종료되어 그 주소 공간을 디스크로 내쫓는 것이 아니라, 특정한 이유로 수행 중인 프로세스의 주소 공간을 일시적으로 메모리에서 디스크로 내려놓는 것을 의미



![](https://velog.velcdn.com/images/hellojihyoung/post/39bf3d28-94fb-422f-9727-8c47eececc49/image.png)
<br>

### 📗 레이저 트리밍
실크 스크린 기법으로 저항기 생성
저항기의 폭이 넓을수록 저항값 ↓
탐침기가 저항기의 저항값 측정하여 레이저로 일부를 태워 저항값이 원하는 수준에 도달할때까지 얇게 만듦

당시 프로그램 아키텍처의 형태 : 마스터 운영 프로그램 MOP

유틸리티 계층이 MOP 계층을 호출하지만, MOP 자체가 유틸리티 계층에 특화되도록 변경되었고, MOP가 유틸리티 계층을 호출할때도 있었다 -> 독립된계층이라고 생각 X, 둘이 강하게 결합

격리계층
가상 머신 인터페이스 제공, DSL 언어로 작성

트리밍 작업
테이프에서 로드 -> 시스템에 의해 실행
시스템은 M365 어셈블러로 작성되어 단일 컴파일 단위로 컴파일되어 순수한 바이너리 코드로 생성되었다.

> 모든곳에 결함이 존재했고, 경계도 불분명하고, 강제되지 않았다.

<br>

### 📙 알루미늄 다이캐스팅 모니터링
세트 프로그램 인터럽트라는 명령어를 지원했다.
해당 명령어를 입력하면 프로세서의 인터럽트를 발생시켰고, 이를 통해 우선순위가 낮은 다른 인터럽트를 조작할 수 있었다.

> `Thread.yield()`: 다른 스레드에게 실행 양보 (상태 제어자)

<br>

### 📘 4-TEL
모노리틱 애플리케이션에 아키텍처를 적용
서비스센터가 많은 중앙 사무소 담당
중앙 사무소는 전화 회선처리
전화 발신  및 측정 하드워어는 CO에 위치 (M365 CO에 위치)
CO에 배치된 컴퓨터를 COLT라고 칭함
서비스 지역 컴퓨터(SAC) 라는 또 다른 M365는 서비스 센터에 배치
##### * 모노리틱 : 하나의 애플리케이션 안에 모든 비즈니스 로직이 다 들어가 있는 구조
M365 메모리는 비싸고 덩치가 커서 역할을 분리하기로 함
- SAC : 결과 분석 및 출력
- COLT : 전화 걸고 회선 측정

경계를 나눠 속도 향상 메모리 사용 줄임

-----------

소프트웨어 수정 시 칩을 모두 교체해야 한다는 문제 발생 : 벡터화로 해결
- 독립적으로 컴파일 가능한 소스파일로 분리 / 로드할 주소를 알려줄 수 있도록 표시
- 소스파일의 시작 부분에는 고정된 크기의 데이터 구조 생성 / 서브루틴 주소 저장
- RAM 에 벡터라는 특수 영역 생성 / 서브루틴 호출을 RAM 벡터를 통해 간접 호출로 변환


> `배포 독립성`을 가질 수 있도록 함
> 플러그인 아키텍처
> ![](https://velog.velcdn.com/images/hellojihyoung/post/d8b53edc-69a8-49cc-a064-f9fcb8a294e9/image.png)




<br>

### 📒 4-TEL 서비스 지역 컴퓨터(SAC)

#### 파견 결정하기
클린 코드의 가치
고칠수 있도록 남이 읽을 수 있도록 설계해야함

#### 아키텍처
하드웨어를 업무 규칙에서 격리하는 일의 가치, 그리고 인터페이스를 추상화 하는 일의 가치를 배웠다.

#### 손이 닿지 않는 야심찬 재설계
SAC 소프트웨어 아키텍처 재설계 -> 지연
왜?

#### 유럽
미국과 영국 사이의 모듈이 너무 달라졌고, 독립적으로 수정되던 코드를 통합하고자 하는 시도가 실패했다.
-> 이분화 문제로 인하여

#### SAC의 결론
?


<br>


### 📕 C 언어
어셈블리 to c언어

<br>



### 📗 BOSS
선점형 방식 -> 비선점형 방식
![업로드중..](blob:https://velog.io/2b4778f5-0f38-4843-bcdf-29976c195813)

<br>


### 📙 pCCU
디지털 혁명
아날로그 방식의 중앙 교환 장비를 디지털 교환기로 대체
-> CCU/CMU 아키텍처 도입

사실 이게 필요없었다.
중앙 교환국에 간단한 컴퓨터를 배치하고 모뎀 회선을 이용하여 분배 거점에 있는 두대의 표준 COLT와 연결하기만 하면 됐다.
>`BOSS 기반, C로 작성`

<br>

### 📘 DLU/DRU
#### DLU 
- 터미널 관리자 보드
- 문자 스트림을 받아 모뎀 링크를 통해 다중화
- 데이터 흐름 모델을 기반으로 함
   - 흐름상의 각 태스크는 작은 문제를 처리하고, 출력을 큐를 통해 다음 태스크에 전달 : 파이프, 필터 모델
   

#### DRU 
- 고객사의 원격지에 배치되는 상자
- 터미널 별로 하나의 태스크를 생성하고, 해당 터미널에서 필요한 작업을 하나의 태스크에서 모두 처리
   - 할당된 터미널을 관리하는, 완전하게 동일한 거대한 태스크가 여러개 존재

>소프트웨어 아키텍처가 완전히 다를지라도 효과는 동등할 수 있다는 사실을 받아들이게 되었다.
→ 소프트웨어 아키텍처는 동작을 더 잘하게 만드는 것이라기 보다는 다른 것에 더 큰 가치가 있다는 이야기로 보인다.
→ 개발, 배포, 유지보수 등등


<br>

### 📒 VRS : 음성 응답 시스템
데이터베이스는 세부사항이며, 시스템의 전반적인 업무목적과는 반드시 분리해야 한다.


<br>


### 📕 전자 접수원
##### * 서비스 지향 아키텍처 SOA : 대규모 컴퓨터 시스템을 구축할때의 개념으로 업무상에 SoftWare기능을 서비스로 판단하여 그 서비스를 네트워크상에 연동하여 전체를 구축하는 방법론

이 시스템은 진짜 경계가 있다는 표시를 분명하게 보여주었다. 서비스는 독립적으로 배포할 수 있었으며, 자신이 채임지는 도메인 내에서 동작했다.

고수준의 프로세스와 저수준의 프로세스가 있었고, 의존성의 많은 부분이 올바른 방향을 향했다.

<br>

### 📗 CDS
상태 머신을 외부적으로 표현함으로써 코드를 변경하지 않고도 애플리케이션의 흐름을 변경할 수 있었다. (개방 폐쇄 원칙, OCP)

##### * OCP : 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다.
<br>

### 📙 Clear Communication


<br>

### 📘 ROSE
가장 큰 실수는 과도한 아키텍처였다. 
이 책에서 설명한 계층보다 훨씬 많은 계층이 있었고,
각 계층은 자신만의 독특한 통신오버헤드를 발생시켰다. 
이로 인해 팀 생산성은 급격하게 떨어졌다.
이를 통해 나는 아키텍처가 뛰어나더라도 커다란 실패로 끝날 때도 있다는 사실을 배웠다.
> 아키텍처는 반드시 문제의 규모에 적합할 정도만큼만 유연해야 한다.


<br>

### 📒 건축사 인증 시험

유사한 표현 방식과 매커니즘을 이용하기에 공유되는 요소를 바탕으로 프레임워크를 개발하기로 한다.
시행착오를 거쳐 만들어진 프레임워크는 GUI 어플리케이션과 의존성 규칙을 준수했다.
비네트는 프레임워크에 플러그인 형태로 연결되었으며
고수준의 GUI 정책은 모두 프레임워크 내부로 들어갔다.


> 사용할 수 있는 프레임워크를 먼저 완성해야 비로소 재사용 가능한 프레임워크를 만들 수 있다.


<br>

### 📚 Reference
- Clean Architecture : 소프트웨어 구조와 설계의 원칙
- 스와핑 : https://boycoding.tistory.com/261
